https://www.youtube.com/@ezcd

데이터 베이스 설계

```text
19. DB 테이블 설계 잘못하면 어떤 문제가 생길 수 있을까요?
    1. 중복 데이터 문제
        데이터 삽입 이상현상 (insertion anomalies)
            - 사원 데이터와 소속 데이터를 하나의 테이블로 관리하면 소속 데이터는 중복이 된다.
                저장 공간 낭비, 실수로 인한 데이터 불일치(예. 누구는 소속이 DEV 누구는 DEB 로 되어 불일치) 가능성 존재
            - 소속이 아직 없는 사원이라면 ? 소속 데이터는 null 을 사용하게된다. (null 을 너무 많이 사용)
            - 임직원이 없는 부서를 등록하려면 ? 직원 데이터는 모두 null 이고 매끄럽지도 않음
            - 새로운 부서에 새로운 직원을 등록하려면 ? 기존에 등록한 부서정보는 삭제하고 새로운 tuple 로 직원 등록 해야함
            
            별개의 관심사가 하나의 테이블에 구성되어 있다.
            
        데이터 삭제 이상현상 (deletion anomalies)
            - QA 부서에 존재하는 하나의 직원 데이터를 삭제하면 QA 부서 정보 자체도 사라지게 된다.
            - 위 문제를 해결하기 위해 해당 직원의 데이터를 null 로 대체한다면 매끄럽지 않고 null 을 너무 많이 사용한다.
        
        데이터 수정 이상현상 (update anomalies)
            - DEV 부서를 DEV1 로 변경했는데 하나의 직원만 업데이트가 됐다면, 부서 이름 불일치가 발생 한다.
            
    2. Spurious Tuples(Spurious 뜻 가짜)
        DEPARTMENT_PROJECT natural join DEPARTMENT_LOCATION
            프로젝트 위치 attribute 로 조인을 하여 해당 위치의 여러 부서 이름이 있기에, 가짜 정보(Spurious Tuple)가 발생한다.
                없던 정보가 생김
                그래서 부서, 프로젝트, 부서가 참여하고 있는 프로젝트 이렇게 세가지 테이블이 필요하다.
                
    3. null 값이 많아짐으로 인한 문제점들
        null 값이 있는 column 으로 join 하는 경우, 상황에 따라 예상과 다른 결과 발생
        null 값이 있는 column 에 aggregate function(집계 함수) 을 사용했을 때 주의 필요
            (예. null 이 아닌 값만 count 를 하게 됨, count(*) 를 사용하면 전체 tuple 의 수로 count 하게 됨)
        불필요한 storage 낭비
    
    바른 DB Schema 설계
        1. 의미적으로 관련있는 속성들끼리 테이블을 구성
        2. 중복 데이터를 최대한 허용하지 않도록 설계
        3. join 수행 시 가짜 데이터가 발생하지 않도록 설계
        4. 최대한 null 값을 줄일 수 있도록 설계

20. DB 를 설계하는 방법의 기본이 되는 functional dependency(함수 종속)를 배우게 됩니다.
    Functional dependency : 한 테이블에 있는 두 개의 attribute(s) 집합(set) 사이의 제약(a constraint)
    예. empl_id | empl_name | bitrh_date | position | salary | dept_id
        x = {empl_id}
        y = {empl_name | bitrh_date | position | salary}
        특징 : 두 tuple 의 x 값이 같다면 y 값이 같다.
        
        x 값에 따라 y 값이 유일하게(uniquely) 결정될 때
        'x 가 y 를 함수적으로 결정한다(functionally determine)'
        'x 가 y 에 함수적으로 의존한다(functionally dependency)'
        라고 말할 수 있고, 두 집합 사이의 이러한 제약 관계를 Functional Dependency(FD) 라고 한다.
        기호로 표현한다면 X(left-hand side) -> Y(right-hand side) 집합 X가 집합 Y를 결정한다(특정할 수 있다) 라는 의미이다.
        
        Functional dependency(FD) 파악하기
            테이블의 스키마를 보고 의미적으로 파악해야 한다.
            즉, 테이블의 state 를 보고 FD를 파악해서는 안된다.
                테이블의 특정 순간의 특정 상태(state)만 보고 {empl_name}->{birth_date}가 존재한다고 생각하면 안된다.
                같은 이름이라고 생일이 같을거라고 생각하면 안된다는 뜻.
        
        만약 y에 dept_id가 포함된다면 x가 y를 결정할 수 있을까?
            임직원은 반드시 한 부서에만 속해야 한다면 가능하다.
            임직원이 하나 이상의 부서에 속해야한다면 불가능하다.
        
        구축하려는 DB의 attribute 가 관계적으로 어떤 의미(semantic)를 지닐지에 따라 FD 들이 달라진다.

        예. FD
            {stu_id} -> {stu_name, birth_date, address}
            {class_id} -> {class_name, year, semester, credit}
            {stu_id, class_id} -> {grade}
            {bank_name, bank_account} -> {balance, open_date}
        
        X -> Y not means Y -> X
            {empl_id} -> {empl_name} but {empl_id} <X- {empl_name} 동명이인이 있을 수 있다.
            {empl_id} -> {SSN} and {empl_id} <- {SSN} id 에 따라 주민번호를 특정할 수 있고 주민번호는 고유하기에 반대로도 가능하다.
        
        {} -> Y
            공집합이 Y 집합을 결정한다.
            Y 값은 언제나 하나의 값만을 가진다는 의미.
            proj_id ... company
            1001        ez.
            1002        ez.
            company 값이 항상 ez. 라면 {} -> {company} 라는 의미이다.
            (정규화의 second normal form(2NF)에 관련)
        
        Trivial functional dependency
            when X -> Y hold, if Y is subset of X, then X -> Y is trivial FD
            X가 Y를 결정하는 FD 가 유효할 때, 만약 Y가 X의 부분집합이라면, 그땐 X->Y 가 trivial FD 라고 한다.
                {a,b,c} -> {c} is trivial FD
                {a,b,c} -> {a, c} is trivial FD
                {a,b,c} -> {a, b, c} is trivial FD
        
        Non-trivial functional dependency
            when X -> Y hold, if Y is NOT subset of X, then X -> Y is non-trivial FD
                {a,b,c} -> {b, c, d} is non-trivial FD
                {a,b,c} -> {d, e} is non-trivial FD & completely non-trivial FD
                    이 두 집합은 공통된 attributes 가 하나도 없다.
        
        Partial functional dependency
            when X -> Y holds,
            if 'any proper subset of X' can determine Y, then X -> Y is partial FD
            X가 Y를 결정하는 FD가 유효할 때, X 집합의 어떤 하나의 proper subset 이라도 Y를 determine(결정하다) 할 수 있다면
            X -> Y 는 partial FD 라고 부른다.
                proper subset
                - 집합 X의 proper subset 은 X의 부분 집합이지만 X와 동일하지 않은 집합
                - X = {a,b,c} 라면 {a,c}, {a}, {}는 모두 X의 proper subset 이다.
                - 반면 {a,b,c} 는 X의 proper subset 이  아니다.
            when {empl_id, empl_name} -> {bitrh_date} holds,
            because {empl_id} can determine {birth_date},
            then this FD is partial FD
           
        Full functional dependency (partial functional dependency 가 아닌 경우)
            when X -> Y holds,
            if 'every proper subset of X' can NOT determine Y, then X -> Y is full FD
            
            when {stu_id, class_id} -> {grade} holds,
            because {stu_id}, {class_id}, {} can NOT determine {grade},
                stu_id 는 여러 class_id 를 갖고 class_id 도 여러 stu_id 를 갖기에 결정할 수 없다.
            then this FD is full FD
            
            정규화에서 이 개념을 사용
    
    FD와 관련된 추가적인 개념(실무에서 크게 중요하지는 않는 개념)
        Armstrong's axioms
        Closure
        minimal cover

21. (1부) DB 정규화(normalization)는 DB를 설계하는 공식적인 방법이죠~ 1부에서는 정규화 개념과 정규화 과정의 앞 부분인 1NF, 2NF를 설명합니다 :)
    
























































```
