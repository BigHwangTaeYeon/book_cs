# 조인의 원리
조인의 원리는 중첩 루프 조인, 정렬 병합 조인, 해시 조인이 있습니다.<br>

### 중첩 루프 조인(NLJ, Nested Loop Join)
중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이며, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않습니다.

예를 들어 "t1 t2 테이블을 조인한다" 하였을 때,<br>
첫 번째 테이블에서 행을 한 번에 하나씩 읽고<br>
그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환합니다.
```shell
for each row in t1 matching reference key {
    for each row in t2 matching reference key {
        if row satisfies join conditions, send to client
    }
}
```
참고로 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠 블록 하나씩 조인하는<br>
블록 중첩 루프 조인(BNL, Block Nested Loop)이라는 방식도 있습니다.

### 정렬 병합 조인
각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인입니다.<br>
조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 사용합니다.

### 해시 조인
해시 테이블 기반으로 조인하는 방법입니다.<br>
두 테이블을 조인한다 하였을 때, 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적입니다.<br>
(메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생됩니다.)<br>
또한 동등(=) 조인에서만 사용할 수 있습니다.

##### MySQL 해시 조인 단계
- 빌드 단계<br>
입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계입니다.<br>
두 테이블을 조인한다면 바이트가 더 작은 테이블을 기반으로 빌드합니다.<br>
조인에 사용되는 필드가 해시 테이블의 키로 사용됩니다.<br>

- 프로브 단계<br>
프로브 단계 동안 레코드 읽기를 시작하며, 각 레코드에서 키로 사용되는 값이 일치하는 레코드를 찾아 결괏값으로 반환합니다.

이를 통해 루프 조인보다 보통은 성능이 더 좋습니다.<br>
참고로 사용 가능한 메모리양은 시스템 변수 join buffer size 에 의해 제어되며, 런타임 시에 조정할 수 있습니다.
