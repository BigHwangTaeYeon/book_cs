자료 구조(data structure)는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합을 말합니다.

# 복잡도
복잡도는 시간 복잡도와 공간 복잡도로 나뉩니다.

### 시간 복잡도

##### 빅오 표기법
시간 복잡도란 '문제를 해결하는 데 걸리는 시간과 입력의 함수 관계'를 가리킵니다.
어떠한 알고리즘의 로직이 '얼마나 오랜 시간'이 걸리는지를 나타내는 데 쓰이며, 보통 빅오 표기법으로 나타냅니다.

입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타내는 것입니다.

##### 시간 복잡도의 존재 이유
효율적인 코드로 개선하는 척도로 쓰입니다.
이벤트가 발생하는 로직이 O(n^2)의 시간 복잡도를 가지고 9초가 걸리는 것을
O(n)의 시간 복잡도를 가지는 알고리즘으로 개선한다면 3초가 걸리게 될 것입니다.

##### 시간 복잡도의 속도 비교
O(n^2) 보다는 O(n), O(n) 보다는 O(1)을 지향해야 합니다.

### 공간 복잡도
프로그램을 실행시켰을 때, 필요로 하는 자원 공간의 양을 말합니다.
정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함합니다.

### 자료 구조에서의 시간 복잡도

- 자료 구조의 평균 시간 복잡도
|자료 구조|접근|탐색|삽입|삭제|
|------|---|---|---|---|
|배열(Array)|O(1)|O(n)|O(n)|O(n)|
|스택(Array)|O(n)|O(n)|O(1)|O(1)|
|큐(Array)|O(n)|O(n)|O(1)|O(1)|
|이중 연결 리스트(Array)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(Array)|O(1)|O(1)|O(1)|O(1)|
|이진 탐색 트리(Array)|O(logn)|O(logn)|O(logn)|O(logn)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리(Array)|O(logn)|O(logn)|O(logn)|O(logn)|

- 자료 구조 최악의 시간 복잡도
|자료 구조|접근|탐색|삽입|삭제|
|------|---|---|---|---|
|배열(Array)|O(1)|O(n)|O(n)|O(n)|
|스택(Array)|O(n)|O(n)|O(1)|O(1)|
|큐(Array)|O(n)|O(n)|O(1)|O(1)|
|이중 연결 리스트(Array)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(Array)|O(n)|O(n)|O(n)|O(n)|
|이진 탐색 트리(Array)|O(n)|O(n)|O(n)|O(n)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리(Array)|O(logn)|O(logn)|O(logn)|O(logn)|

그렇다면 최악의 경우, 최선의 경우, 평균의 경우란 무엇일까요?
예를 들면 우리가 어떤 오름차순 정렬 알고리즘을 하나 만들었다고 칩시다.

똑같은 정렬 알고리즘이라고 해도 입력의 개수가 10인 경우와 1억개인 경우는 수행시간이 다를 것입니다.
⚠️그런데 최선, 최악, 평균의 경우는 이게 포인트가 아닙니다.

입력의 개수가 100개, 100개로 서로 같다고 가정했을 때, 어떤 자료 집합은 대부분의 숫자가 
{12, 15, 22..} 처럼 대부분 미리 정렬되어 있어서 알고리즘의 수행시간이 적게 걸릴 수 있고, 
어떤 자료집합은 숫자가 여기저기 흩어져 있어서 수행시간이 더 오래 걸릴 수 있습니다.

이분탐색을 경우로 예를 들자면 이분 탐색은 어떠한 자료집합이 주어지든 간에
가장 빠르게 찾는 경우는 1번만에 찾는 경우일 것이고 가장 느리게 찾는 경우는 log2n일 것입니다.
왜냐하면 내가 찾으려고 하는 수가 가장 가운데에 있다면 한번만에 성공할 것이고
최대한 많이 탐색의 범위를 줄인다고 해도 최대 log2n번만에 찾을 것이기 때문입니다.

수행 시간의 범위가 1~log2n이 되는 것이죠.
주어지는 자료의 수가 10개이든 1억개이든 만족하게 됩니다. 

이분탐색의 최악, 최선
이처럼 최악의 경우란 입력 자료 집합을 알고리즘에 최대한 불리하도록 만들어서 얼마만큼의 시간이 소모되는 지를 분석하는 것입니다. 
최선의 경우란 반대로 알고리즘에 최대한 유리하도록 만들어서 얼마만큼의 시간이 소모되는 지를 측정하는 것입니다.
(평균의 경우는 모든 입력과 각 입력이 발생하는 확률까지 고려하여 평균적인 수행시간을 구합니다. 평균을 구하기는 상당히 어렵기 때문에 잘 사용하진 않습니다.)

[출처] (자료구조) 시간복잡도 '빅오와 최악 구별하기'|작성자 써밋 (https://blog.naver.com/ygs1090/223014807078)