# 선형 자료 구조
요소가 일렬로 나열되어 있는 자료 구조

### 연결 리스트(LinkedList to java)
데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료구조.
삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸립니다.

prev 포인터와 next 포인터로 앞 뒤 노드를 연결시킨 것이 연결 리스트이며,
연결 리스트는 싱글 연결 리스트, 이중 연결 리스트, 원형 이중 연결 리스트가 있습니다.
맨 앞에 있는 노드를 헤드(head)라고 합니다.

- 싱글 연결 리스트 : next 포인터만 가집니다.
- 이중 연결 리스트 : next 포인터와 prev 포인터를 가집니다.
- 원형 이중 연결 리스트 : 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것을 말합니다.

### 배열(Array)
같은 타입의 변수들로 이루어지며, 크기가 정해져있고, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합(정적 배열).
* 중복을 허용하고 순서가 있습니다.

탐색에 O(1)이 되어 랜덤 접근(random access)이 가능합니다.
삽입과 삭제에는 O(n)이 걸립니다.

*** 데이터 주가 삭제를 많이 하는 것은 연결리스트, 탐색을 많이 하는 것은 배열 ***

배열은 인덱스에 해당하는 원소를 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용합니다.

##### 랜덤 접근과 순차적 접근
직접 접근이라 하는 랜덤 접근은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때,
임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능입니다.
이는 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대입니다.

- 순차접근
1   |   2   |   3   |   4   |   ...
    >       >       >       >   ...

- 랜덤 접근
3   |   5   |   2   |   4   |   ...
    <
                    >
            <
                            >

##### 배열과 연결 리스트 비교
배열은 상자를 순서대로 나열한 데이터 구조, index만 알면 해당 상자의 요소를 얻을 수 있습니다.
연결 리스트는 상자를 선으로 연결한 형태의 데이터 구조이며, 하나씩 상자 내부를 확인해봐야 한다는 점이 다릅니다.

탐색은 배열이 빠르고 연결 리스트는 느립니다.
추가 및 삭제는 연결 리스트가 더 빠르고 배열은 느립니다.

배열은 삭제하면 상자를 앞으로 하나씩 전부 옮겨야 하지만,
연결 리스트는 선만 바꿔 연결해주면 되기 때문입니다.

### 벡터(vector)
    자바에서 잘 쓰이지 않는다.

    Vector의 구현방법에 그 이유가 있다.

    Vector는 get()과 set()역할을 하는 모든 메서드에 synchronized 키워드가 붙어 있다.
    따라서 멀티스레드 프로그래밍을 하는게 아니라면, 비슷한 역할을 하는 ArrayList를 사용하는게 좋다. (ArrayList에는 synchronized 키워드가 전혀 없다.)

    그렇다면 멀티스레드 프로그래밍을 하지 않는 상황에선 ArrayList를 사용하고, 멀티스레드 프로그래밍을 할 때에는 Vector 컬렉션을 사용하면 되는가?
    그 또한 그렇지 않다. Vector의 모든 get() set() 등의 메서드에 synchronized가 붙어있는건 특정 상황에서 성능을 꽤 저하시킬 수 있다.
    단순히 Vector에 Iterator를 붙여 순차적으로 item들을 탐색하기만 해도 원소탐색 시마다 get() 메서드의 실행을 위해 계속 lock을 걸고 닫으므로
    Iterator연산과정 전체에 1번만 걸어주면 될 locking에 쓸데없는 오버헤드가 엄청나게 발생한다.

    따라서 Vector는 특정 상황에서만 최적으로 동작하게 되고, 어떤 상황에서는 그렇지 않게 되므로 효율적인 Thread-safe 컬렉션이라고 할 수 없는 것이다.
    (https://aahc.tistory.com/8)

동적으로 요소를 할당할 수 있는 동적 배열.
컴파일 시점에 개수를 모른다면 백터를 써야 합니다.
중복을 허용하고 순서가 있고 랜덤 접근이 가능합니다.
탐색과 맨 뒤의 요소를 삭제하거나 삽입하는데 O(1),
맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는데 O(n) 시간이 걸립니다.

뒤에서부터 삽입하는 push_back()의 경우 O(1)의 시간이 걸리는데,
벡터의 크기가 증가되는 시간 복잡도가 amortized 복잡도, 즉 상수 시간 복잡도 O(1)과 유사한 시간 복잡도를 가지기 때문입니다.

push_back()이 매번 크기가 증가하는 것이 아니라, 2의 제곱승 +1 마다 크기를 2배로 늘리는 것을 알 수 있습니다.

### 스택
LIFO(Last In First Out)성질을 가진 가료 구조입니다.
삽입 및 삭제에 O(1), 탐색에 O(n) 시간이 걸립니다.
재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰입니다.

### 큐
FIFO(First In, First Out)을 지닌 자료 구조입니다.
삽입 및 삭제에 O(1), 탐색에 O(n) 시간이 걸립니다.
CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비우선 탐색, 캐시 등에 사용됩니다.